/*------------------------------------------------------------------------------
 *******************************************************************************
 * COPYRIGHT Ericsson 2015
 *
 * The copyright to the computer program(s) herein is the property of
 * Ericsson Inc. The programs may be used and/or copied only with written
 * permission from Ericsson Inc. or in accordance with the terms and
 * conditions stipulated in the agreement/contract under which the
 * program(s) have been supplied.
 *******************************************************************************
 *----------------------------------------------------------------------------*/
package com.ericsson.oss.itpf.security.pki.manager.event.notification.cmp.validator;

import java.io.IOException;

import java.security.*;
import java.util.Arrays;

import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.ejb.EJB;
import javax.inject.Inject;

import org.slf4j.Logger;


import com.ericsson.oss.itpf.security.pki.common.cmp.model.IAKParameters;
import com.ericsson.oss.itpf.security.pki.common.cmp.model.RequestMessage;
import com.ericsson.oss.itpf.security.pki.common.util.constants.ErrorMessages;
import com.ericsson.oss.itpf.security.pki.manager.exception.entity.EntityNotFoundException;
import com.ericsson.oss.itpf.security.pki.manager.exception.entity.EntityServiceException;
import com.ericsson.oss.itpf.security.pki.manager.exception.entity.endentity.otp.OTPExpiredException;
import com.ericsson.oss.itpf.security.pki.manager.exception.entity.endentity.otp.OTPNotSetException;
import com.ericsson.oss.itpf.security.pki.manager.local.service.api.EntityManagementLocalService;

/**
 * This class used for IAK validation on PKIMessage generated by entity for cmpv2 enrollemnt process.
 * 
 * @author tcsdesa
 * 
 */
public class IAKValidator {

    @Inject
    Logger logger;

    @EJB
    EntityManagementLocalService entityManagementLocalService;

    /**
     * This method does the IAK validation for the CMP request message. the salt value is extracted and appended to the OTP. The OWF is then applied iterationCount times, where the salted secret is
     * the input to the first iteration and, for each successive iteration, the input is set to be the output of the previous iteration. The output of the final iteration is what is used to form the
     * IAK key.
     * 
     * @param entityName
     *            the entity name for which the OTP is fetched from the manager database
     * 
     * @param pKIRequestMessage
     *            the message having information for certificate request.
     * 
     * 
     * @throws IAKValidationException
     *             is thrown when IAK validation fails.
     */

    public void verifyPasswordBasedMac(final String entityName, final RequestMessage pKIRequestMessage) throws IAKValidationException {
        try {
            final IAKParameters iakParameters = new IAKParameters(pKIRequestMessage);
            final byte[] salt = iakParameters.getSaltOctets();
            final byte[] raSecret = getSecretKey(entityName);
            final byte[] protection = pKIRequestMessage.getProtectionBytes();

            logger.debug("Validating IAK for IR request for transaction Id:{}", pKIRequestMessage.getBase64TransactionID());

            byte[] basekey = generateBaseKey(raSecret, salt);
            basekey = updateBaseKey(basekey, iakParameters);
            final byte[] hashValueOfBaseKey = computeHash(basekey, iakParameters);

            if (!verifyProtection(hashValueOfBaseKey, protection)) {
                logger.error("IAK validation failed for :{} ", pKIRequestMessage.getRequestMessage());
                final String errorMessage = ErrorMessages.IAK_AUTHENTICATION_FAILED;
                throw new IAKValidationException(errorMessage);
            }

        } catch (IllegalStateException illegalStateException) {
            throwIAKValidationException(illegalStateException, ErrorMessages.MAC_NOT_INITIALIZED);

        } catch (IOException ioException) {
            throwIAKValidationException(ioException, ErrorMessages.IO_EXCEPTION);

        } catch (NoSuchAlgorithmException noSuchAlgorithmException) {
            throwIAKValidationException(noSuchAlgorithmException, ErrorMessages.INVALID_ALGORITHM);

        } catch (InvalidKeyException invalidKeyException) {
            throwIAKValidationException(invalidKeyException, ErrorMessages.INVALID_KEY_FOR_MAC);
        }
    }

    private byte[] generateBaseKey(final byte[] raSecret, final byte[] salt) {
        final int raSecretLength = raSecret.length;
        final int saltLength = salt.length;
        final byte[] baseKey = new byte[raSecretLength + saltLength];
        System.arraycopy(raSecret, 0, baseKey, 0, raSecretLength);
        System.arraycopy(salt, 0, baseKey, raSecretLength, saltLength);
        return baseKey;
    }

    private byte[] computeHash(final byte[] basekey, final IAKParameters iakParameters) throws IllegalStateException, IOException, NoSuchAlgorithmException, InvalidKeyException {

        final String macOid = iakParameters.getMacOid();
        final SecretKey secretKey = new SecretKeySpec(basekey, macOid);
        final Mac mac = Mac.getInstance(macOid);
        mac.init(secretKey);
        final byte[] hash = mac.doFinal(iakParameters.getProtectedPart());
        return hash;

    }

    private byte[] updateBaseKey(byte[] basekey, final IAKParameters iakParameters) throws NoSuchAlgorithmException {
        MessageDigest messageDigest = null;
        int iterationCount = 0;

        iterationCount = iakParameters.getIAKIterationCount();
        messageDigest = MessageDigest.getInstance(iakParameters.getOWFId());
        for (int iterator = 0; iterator < iterationCount; iterator++) {
            basekey = messageDigest.digest(basekey);
            messageDigest.reset();
        }
        return basekey;
    }

    private boolean verifyProtection(final byte[] hash, final byte[] protection) {

        final boolean isValid = Arrays.equals(hash, protection);
        if (!isValid) {
            logger.info("CMPMessageValidator MAC is not valid");
        }
        return isValid;
    }

    private String getOTP(final String entityName) throws IAKValidationException {
        String raAuthenticationSecret = null;
        try {
            raAuthenticationSecret = entityManagementLocalService.getOTP(entityName);
        } catch (EntityNotFoundException | EntityServiceException | OTPExpiredException | OTPNotSetException exception) {
            throw new IAKValidationException(exception.getMessage(), exception);
        }
        return raAuthenticationSecret;
    }

    private byte[] getSecretKey(final String entityName) throws IAKValidationException {
        final String raAuthenticationSecret = getOTP(entityName);
        return raAuthenticationSecret.getBytes();

    }

    private void throwIAKValidationException(final Throwable throwable, final String errorMessage) throws IAKValidationException {

        logger.error(throwable.getMessage());
        logger.debug("Exception StackTrace", throwable);
        throw new IAKValidationException(errorMessage, throwable);

    }
}
